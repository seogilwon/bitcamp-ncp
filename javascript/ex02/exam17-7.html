<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ex02</title>
</head>
<body>
<h1>연산자 - 기타연산자</h1>
<button id="btn1">버튼</button>
<script>
"use strict"   //문법을 엄격하게 체크하라는 문법

// 조건 연산자
// - 조건 ? 표현식1 : 표현식2;
// - 조건이 참이면, 표현식1을 실행하고 그 결과를 리턴한다.
// - 조건이 거짓이면, 표현식2를 실행하고 그 결과를 리턴한다.
// 
let age = 27;
let message = age < 20 ? "미성년입니다" : "성년입니다";
console.log(message);
console.log(age < 20 ? "미성년입니다" : "성년입니다");

//조건 연산자를 수행한 후 결과를 반환하는 용도로 사용하라.
// 다음과 같이 결과를 반환하지 않고 문장을 실행시키고 싶다면 조건문을 사용하라!
age < 20 ? console.log("미성년입니다") : console.log("성년입니다");   //비추

if (age < 20) {                        //조건문
  console.log("미성년입니다");
  }
  else {
  console.log("미성년입니다");
  }

console.log("----------------------");

// 쉼표 연산자
let a = 100, 
    b = 200, 
    c = 300;
console.log(a, b, c);
console.log("----------------------");

const obj = new Object();
obj.name = "홍길동";  //객체 변수 = 프로퍼티
obj.age = 20;

console.log(obj);


// delete 연산자
// - 객체에 추가한 프로퍼티를 제거한다.
delete obj.name;
console.log(obj);

delete obj["age"];
console.log(obj);
console.log("----------------------");


// typeof 연산자
// - 피연산자의 타입을 문자열로 리턴한다.
let v = "홍길동"
console.log(typeof v);

v = 100;
console.log(typeof v);

console.log((typeof v) == "number")


// void 연산자
// - 표현식의 결과를 리턴하지 않는다.
// - 문장 중에 실행 결과를 리턴하는 문장(statement)을 표현식(expression)이라 부른다.
let x = 20;
let y = 30;

console.log(x + y); //x + y 문장은 표현식이다. 왜? 값을 리턴하기 때문이다.
console.log(void (x + y));  //리턴하지 않는다. undefined
console.log("----------------------");


// in 연산자
// - 객체에 해당 이름을 가진 프로퍼티가 있는지 검사한다.
const obj2 = {
  name: "홍길동",
  age: 20,
  working: true,
  print() {
    console.log(this.name + '(' + this.age + ',' + this.working + ')');
  }
};

console.log(obj2);
obj2.print();

console.log('name' in obj2); //객체(덩어리)에 있는지?
console.log('age' in obj2);
console.log('working' in obj2);
console.log('print' in obj2);
console.log('tell' in obj2);
console.log("----------------------");

// instanceof 연산자
// - 객체를 만들때 초기화시킨 생성자가 맞는지 검사한다. (누굴통해서초기화되는지?)
const obj3 = new Object();
const obj4 = {};
const obj5 = new Date();

console.log(obj3 instanceof Object);
console.log(obj4 instanceof Object);
console.log(obj5 instanceof Object);
// Date() 생성자
// new Date() 하면,,, new 이기때문에 1) 빈객체 생성된다.(key와 value)
// 2) Date () => Object()  초기화시킨다. (key와 value)
// 3) 날짜관련 프로퍼티(변수,함수) 추가한다. (getDay, gethours)
//
// ex) new HTMLButtonElement()           =>핵심 기존 코드 재사용
// 1) new라는게 빈 객체를 만든다. (key, value)
// 2) Object를 통해서 기본객체프로퍼티 추가
// 3) Eventtarget이 초기화시킴
// 4) Node() 관련 프로퍼티 추가
// 5) Element 관련 추가
// 6) HTMLElemet 관련 추가
// 7) HTMLButtonElement 초기화

const obj6 = document.getElementById("btn1");
console.log(obj6);
console.log(obj6.constructor);
console.log(obj6 instanceof HTMLButtonElement);
console.log(obj6 instanceof HTMLElement);
console.log(obj6 instanceof Element);
console.log(obj6 instanceof Node);
console.log(obj6 instanceof EventTarget);
console.log(obj6 instanceof Object);
console.log(obj6 instanceof Date);




</script>
</body>
</html>















