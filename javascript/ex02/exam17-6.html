<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ex02</title>
</head>
<body>
<h1>연산자 - 비트연산자</h1>
<script>
"use strict"   //문법을 엄격하게 체크하라는 문법


let a = 0b01100100;
let b = 0b11110000;


// AND 비트 연산자
// - 두 비트가 1일때 1, 그외 0
// - 1로 설정한 비트의 값은 그대로 통과하는 효과가 있다.
// - 특정 비트의 값만 추출할때 사용한다.
console.log((a & b).toString(2));   // ==> 1100000

// 응용1
// - 색상 값에서 빨강 색을 제거하기
// - 예) 사진에서 빨강색 제거 (그래픽편집툴에서 많이 사용)
let color = 0xFF00FF;  //보라색
console.log((color & 0x00FFFF).toString(16)); // 0000FF


// OR 비트 연산자
// - 두 비트 중에 한개라도 1이면 결과는 1, 그외 0
// - AND 비트 연산자와 반대로 동작
// - 0 비트는 그대로 통과, 1비트는 기존 값 제거.
console.log((a | b).toString(2)); // 11110100
console.log("----------------------");


// 응용
// - 특정 색상을 강화하기
// - 예) 빨강색 강화하기
color = 0x283386;
console.log(color.toString(2));
console.log((color | 0x550000).toString(2)); // 빨강색 강화: 01010101
// 기존 빨강색 : 00101000
// 빨강색 강화 : | 01010101
// ----------------------------
// 변경된색상 : 01111101
console.log("----------------------");


// XOR(exclusive OR) 비트 연산자
// - 두 비트의 값이 다를 때 1, 같으면 0
console.log((a ^ b).toString(2));
// a: 01100100
// b: 11110000 ^
//---------------
//    10010100
console.log("----------------------");


// NOT 비트 연산자
console.log((~a).toString(2));
// a: 01100100
//--------------
// ~  10011011
console.log("----------------------");


// << 왼쪽 비트 이동 연산자 
// - 왼쪽으로 지정한 비트만큼 이동시킨다.
// - 오른쪽의 빈 자리는 0으로 채운다.
// - 1비트 이동할때마다 *2한 효과가 있다.
// - *2 연산을 수행하는것보다 비트이동연산자가 실행속도가 더 빠르다.
// - n비트 이동 = 값 * 2**n (2의n승)
a = 7;  //0000111
console.log((a * 2).toString(2));    // 1110   (10진수:14)
console.log((a << 1).toString(2));   // 1110   (10진수:14)
console.log((a * 4).toString(2));    // 11100  (10진수:28)
console.log((a << 2).toString(2));   // 11100  (10진수:28)
console.log((a * 8).toString(2));    // 111000 (10진수:56)
console.log((a << 3).toString(2));   // 111000 (10진수:56)
console.log("----------------------");


// >> 오른쪽 비트 이동 연산자
// - 오른쪽으로 지정한 비트만큼 이동시킨다.
// - 비어있는 왼쪽 빈 자리는 부호비트(양수:0, 음수:1)로 채운다.
// - 1비트 이동할때마다 /2한 효과가 있다.
// - /2 연산을 수행하는것보다 비트이동연산자가 실행속도가 더 빠르다.
// - n비트 이동 = 값 / 2**n (2의n승)
a = 100;  //01100100
console.log((a / 2).toString(2));    // 50
console.log((a >> 1).toString(2));   // 0110010|0   (10진수:50)
console.log((a / 4).toString(2));    // 25
console.log((a >> 2).toString(2));   // 011001|00   (10진수:25)
console.log((a / 8).toString(2));    // 12.5
console.log((a >> 3).toString(2));   // 01100|100   (10진수:12)   (오버플로우된 오른쪽의 100은 짤름.)
console.log("----------------------");


a = -100;  // 양수라면 0110 0100  => 음수는 11111111 11111111 11111111 10011100    (-100)
console.log(a >> 1);                 //     11111111 11111111 11111111 11001110|0   (-50)
// 50  : 0011 0010
// -50 : 1100 1110
console.log((a >> 1).toString(2));   //
console.log("----------------------");

// >>> 오른쪽 비트 이동 연산자
// - 오른쪽으로 지정한 비트만큼 이동시킨다.
// - 비어있는 왼쪽 빈 자리는 0로 채운다. 음수를 비트이동하면 양수로 바뀐다.
// - 양수인 경우 1비트 이동할때마다 /2한 효과가 있다.
// - 양수인 경우, n비트 이동 = 값 / 2**n (2의n승)
a = 100;
console.log((a >>>1));
console.log((a >>> 1).toString(2));
console.log("----------------------");

a = -100;                              // 11111111 11111111 11111111 10011100    (-100)
console.log(a >>> 1);                  // 2147483598
console.log((a >>> 1).toString(2))     // 01111111 11111111 11111111 11001110|0 
console.log("----------------------");






//이미지와 바이트 수
// 1) 흑백사진 => 1픽셀 크기 = 1bit [0:검은색 / 1:흰색]
//             => 9픽셀 크기 = 1픽셀 x 1bit
//                             9픽셀 x 9bit = 9bit
// 2) 칼라사진 => 1픽셀 크기 = RGB 3byte
//             => 9픽셀크기 = 9 x 3 = 27byte
// 3) HD급 크기 사진 = (1920x1080)x3 = 6,220,800byte 
//                                   = 6,075 KB
//                                   = 5.93 MB

//  1920x1080=2,073,600픽셀=2,073,600화소=200만화소
//   천만화소급 사진 = 10,000,000x3 = 30,000,000 = 28MB => 관리하기쉽게 압축
//   압축방법(encoding) : 1)손실압축(JPEG) 2)비손실압축(Gif)
//   압축해제(decoding) :  비트맵(원상태로바꿈) => 출력가능


</script>
</body>
</html>















